from __future__ import annotations

from datetime import date, datetime, time, timedelta
from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple

MAIN_CATEGORIES = [
    "–ó–∞–≤—Ç—Ä–∞–∫",
    "–û–±–µ–¥",
    "–£–∂–∏–Ω",
    "–ü–µ—Ä–µ–∫—É—Å",
    "–°–∞–ª–∞—Ç",
    "–î–µ—Å–µ—Ä—Ç",
    "–ù–∞–ø–∏—Ç–æ–∫",
    "–°—É–ø",
]

MEAL_TYPES = ["–ó–∞–≤—Ç—Ä–∞–∫", "–û–±–µ–¥", "–£–∂–∏–Ω", "–ü–µ—Ä–µ–∫—É—Å"]
DIFFICULTY_LEVELS = ["–õ–µ–≥–∫–æ", "–°—Ä–µ–¥–Ω–µ", "–°–ª–æ–∂–Ω–æ"]
SKIP_KEYWORD = "–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å"
FINISH_INGREDIENT_KEYWORDS = {"–≥–æ—Ç–æ–≤–æ", "–¥–∞–ª–µ–µ", "—Ö–≤–∞—Ç–∏—Ç", "—Å—Ç–æ–ø", "–≤—Å–µ", "–≤—Å—ë"}
YES_ANSWERS = {"–¥–∞", "–∫–æ–Ω–µ—á–Ω–æ", "–∞–≥–∞", "yes", "y"}
NO_ANSWERS = {"–Ω–µ—Ç", "no", "–Ω–µ–∞"}


def normalize_decimal(text: str) -> str:
    return text.replace(",", ".").replace(" ", "").strip()


def parse_float(value: Any) -> Optional[float]:
    if value is None:
        return None
    text = normalize_decimal(str(value))
    if not text:
        return None
    try:
        return float(text)
    except ValueError:
        return None


def parse_int(value: Any) -> Optional[int]:
    number = parse_float(value)
    if number is None:
        return None
    try:
        return int(round(number))
    except (TypeError, ValueError):
        return None


def parse_date_input(text: str) -> Optional[date]:
    normalized = text.strip().lower()
    today = date.today()
    if normalized in {"—Å–µ–≥–æ–¥–Ω—è", "today"}:
        return today
    if normalized in {"–∑–∞–≤—Ç—Ä–∞", "tomorrow"}:
        return today + timedelta(days=1)
    if normalized.startswith("—á–µ—Ä–µ–∑ ") and normalized.endswith(" –¥–Ω–µ–π"):
        number_part = normalized.replace("—á–µ—Ä–µ–∑", "").replace("–¥–Ω–µ–π", "").strip()
        days = parse_int(number_part)
        if days is not None:
            return today + timedelta(days=days)
    for pattern in ("%Y-%m-%d", "%d.%m.%Y", "%d.%m.%y"):
        try:
            return datetime.strptime(normalized, pattern).date()
        except ValueError:
            continue
    return None


def parse_time_input(text: str) -> Optional[time]:
    normalized = text.strip()
    for pattern in ("%H:%M", "%H.%M", "%H %M"):
        try:
            return datetime.strptime(normalized, pattern).time()
        except ValueError:
            continue
    return None


def parse_ingredient_input(text: str) -> Dict[str, Any]:
    parts = [part.strip() for part in text.split(";")]
    if not parts or not parts[0]:
        raise ValueError("–ù–∞–∑–≤–∞–Ω–∏–µ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ")
    ingredient: Dict[str, Any] = {"name": parts[0]}
    if len(parts) > 1 and parts[1]:
        ingredient["quantity"] = parse_float(parts[1])
    if len(parts) > 2 and parts[2]:
        ingredient["unit"] = parts[2]
    macros_keys = ["calories", "protein", "fat", "carbs"]
    for index, key in enumerate(macros_keys, start=3):
        if len(parts) > index and parts[index]:
            ingredient[key] = parse_float(parts[index])
    return ingredient


def compute_macros(ingredients: Sequence[Dict[str, Any]], ratio: float = 1.0) -> Dict[str, float]:
    totals = {"calories": 0.0, "protein": 0.0, "fat": 0.0, "carbs": 0.0}
    for ingredient in ingredients:
        for key in totals.keys():
            value = ingredient.get(key)
            if value is not None:
                totals[key] += float(value) * ratio
    return totals


def format_macros(macros: Dict[str, float]) -> str:
    meaningful = {key: value for key, value in macros.items() if value}
    if not meaningful:
        return ""
    parts = []
    if macros.get("calories"):
        parts.append(f"–ö–∫–∞–ª: {round(macros['calories'], 1)}")
    if macros.get("protein"):
        parts.append(f"–ë: {round(macros['protein'], 1)} –≥")
    if macros.get("fat"):
        parts.append(f"–ñ: {round(macros['fat'], 1)} –≥")
    if macros.get("carbs"):
        parts.append(f"–£: {round(macros['carbs'], 1)} –≥")
    return ", ".join(parts)


def humanize_minutes(value: Optional[int]) -> Optional[str]:
    if not value:
        return None
    minutes = int(value)
    hours, minutes = divmod(minutes, 60)
    parts = []
    if hours:
        parts.append(f"{hours} —á")
    if minutes:
        parts.append(f"{minutes} –º–∏–Ω")
    return " ".join(parts) if parts else None


def format_duration(prep: Optional[int], cook: Optional[int]) -> Optional[str]:
    prep_text = humanize_minutes(prep)
    cook_text = humanize_minutes(cook)
    if prep_text and cook_text:
        return f"–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞: {prep_text}, –≥–æ—Ç–æ–≤–∫–∞: {cook_text}"
    return prep_text or cook_text


def format_ingredients_list(ingredients: Sequence[Dict[str, Any]]) -> str:
    lines = []
    for ingredient in ingredients:
        name = ingredient.get("name")
        if not name:
            continue
        quantity = ingredient.get("quantity")
        unit = ingredient.get("unit") or ""
        amount = ""
        if quantity is not None:
            number = round(float(quantity), 2)
            number = int(number) if number.is_integer() else number
            amount = f" ‚Äî {number} {unit}".strip()
        elif unit:
            amount = f" ‚Äî {unit}"
        macros = format_macros({
            key: ingredient.get(key)
            for key in ("calories", "protein", "fat", "carbs")
            if ingredient.get(key) is not None
        })
        extra = f" ({macros})" if macros else ""
        lines.append(f"‚Ä¢ {name}{amount}{extra}")
    return "\n".join(lines)


def format_dish_card(dish: Dict[str, Any]) -> str:
    parts = [f"üçΩ {dish.get('name', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')}"]
    meta_lines = []
    if dish.get("category"):
        meta_lines.append(f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {dish['category']}")
    if dish.get("cuisine"):
        meta_lines.append(f"–ö—É—Ö–Ω—è: {dish['cuisine']}")
    if dish.get("servings"):
        meta_lines.append(f"–ü–æ—Ä—Ü–∏–π: {dish['servings']}")
    duration = format_duration(dish.get("prep_time"), dish.get("cook_time"))
    if duration:
        meta_lines.append(duration)
    if dish.get("difficulty"):
        meta_lines.append(f"–°–ª–æ–∂–Ω–æ—Å—Ç—å: {dish['difficulty']}")
    if meta_lines:
        parts.append("\n".join(meta_lines))
    tags = dish.get("tags") or []
    if tags:
        parts.append("–¢–µ–≥–∏: " + ", ".join(sorted(tags)))
    if dish.get("description"):
        parts.append(dish["description"])
    ingredients_text = format_ingredients_list(dish.get("ingredients_list", []))
    if ingredients_text:
        parts.append("–ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã:\n" + ingredients_text)
        macros = compute_macros(dish.get("ingredients_list", []))
        macros_line = format_macros(macros)
        if macros_line:
            parts.append(f"–ü–∏—â–µ–≤–∞—è —Ü–µ–Ω–Ω–æ—Å—Ç—å –Ω–∞ {dish.get('servings', 1)} –ø–æ—Ä—Ü.: {macros_line}")
    instructions = dish.get("instructions") or dish.get("recipe")
    if instructions:
        parts.append("–†–µ—Ü–µ–ø—Ç:\n" + instructions)
    if dish.get("notes"):
        parts.append("–ó–∞–º–µ—Ç–∫–∏:\n" + dish["notes"])
    return "\n\n".join(parts)


def parse_tags(text: str) -> List[str]:
    separators = {",", "\n", "#"}
    for separator in separators:
        text = text.replace(separator, ",")
    return [tag.strip() for tag in text.split(",") if tag.strip()]


def build_main_keyboard_layout(summary: Dict[str, Any]) -> List[List[str]]:
    total = summary.get("total_dishes", 0)
    if not total:
        return [["–î–æ–±–∞–≤–∏—Ç—å –±–ª—é–¥–æ", "–ò–º–ø–æ—Ä—Ç"], ["–ü–æ–º–æ—â—å"]]
    layout = [
        ["–î–æ–±–∞–≤–∏—Ç—å –±–ª—é–¥–æ", "–ú–µ–Ω—é"],
        ["–î–æ–±–∞–≤–∏—Ç—å –¥–µ—Ç–∞–ª–∏", "–ò–∑–º–µ–Ω–∏—Ç—å –±–ª—é–¥–æ"],
        ["–£–¥–∞–ª–∏—Ç—å –±–ª—é–¥–æ", "–ü–æ–∏—Å–∫ –ø–æ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–∞–º"],
        ["–ü–ª–∞–Ω –ø–∏—Ç–∞–Ω–∏—è", "–°–ø–∏—Å–æ–∫ –ø–æ–∫—É–ø–æ–∫"],
        ["–ò–∑–±—Ä–∞–Ω–Ω–æ–µ", "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"],
        ["–ò–º–ø–æ—Ä—Ç", "–≠–∫—Å–ø–æ—Ä—Ç"],
        ["–ü–æ–º–æ—â—å"],
    ]
    return layout


def group_plans_by_date(plans: Sequence[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    grouped: Dict[str, List[Dict[str, Any]]] = {}
    for plan in plans:
        grouped.setdefault(plan.get("plan_date"), []).append(plan)
    for items in grouped.values():
        items.sort(key=lambda item: MEAL_TYPES.index(item.get("meal_type")) if item.get("meal_type") in MEAL_TYPES else 99)
    return dict(sorted(grouped.items()))


def format_plan_entries(plans: Sequence[Dict[str, Any]]) -> str:
    if not plans:
        return "–ü–ª–∞–Ω –ø–∏—Ç–∞–Ω–∏—è –ø–æ–∫–∞ –ø—É—Å—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /plan, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –±–ª—é–¥–∞."
    grouped = group_plans_by_date(plans)
    lines: List[str] = []
    for plan_date, entries in grouped.items():
        lines.append(f"üìÖ {plan_date}")
        for entry in entries:
            servings = entry.get("servings")
            servings_text = f" √ó {servings}" if servings else ""
            note = f" ‚Äî {entry['notes']}" if entry.get("notes") else ""
            lines.append(f"  ‚Ä¢ {entry.get('meal_type', '')}: {entry.get('name', entry.get('dish_name', ''))}{servings_text}{note}")
    return "\n".join(lines)


def format_shopping_items(items: Sequence[Dict[str, Any]]) -> str:
    if not items:
        return "–°–ø–∏—Å–æ–∫ –ø–æ–∫—É–ø–æ–∫ –ø—É—Å—Ç ‚Äî –∑–∞–ø–ª–∞–Ω–∏—Ä—É–π—Ç–µ –±–ª—é–¥–∞, —á—Ç–æ–±—ã —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –ø–æ–∫—É–ø–∫–∏."
    lines = ["üõí –°–ø–∏—Å–æ–∫ –ø–æ–∫—É–ø–æ–∫:"]
    for item in items:
        name = item.get("name", "")
        quantity = item.get("quantity")
        unit = item.get("unit") or ""
        amount = ""
        if quantity is not None:
            number = round(float(quantity), 2)
            number = int(number) if number.is_integer() else number
            amount = f" ‚Äî {number} {unit}".strip()
        elif unit:
            amount = f" ‚Äî {unit}"
        macros = format_macros({
            key: item.get(key)
            for key in ("calories", "protein", "fat", "carbs")
            if item.get(key)
        })
        extra = f" ({macros})" if macros else ""
        lines.append(f"‚Ä¢ {name}{amount}{extra}")
    return "\n".join(lines)


def format_recent_actions(actions: Sequence[Dict[str, Any]]) -> str:
    if not actions:
        return ""
    mapping = {
        "dish_added": "–¥–æ–±–∞–≤–ª–µ–Ω–æ –Ω–æ–≤–æ–µ –±–ª—é–¥–æ",
        "dish_updated": "–æ–±–Ω–æ–≤–ª–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –±–ª—é–¥–∞",
        "dish_deleted": "–±–ª—é–¥–æ —É–¥–∞–ª–µ–Ω–æ",
        "details_updated": "–æ–±–Ω–æ–≤–ª–µ–Ω—ã –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã",
        "plan_created": "–¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –ø–ª–∞–Ω",
        "plan_deleted": "—É–¥–∞–ª–µ–Ω–æ –∏–∑ –ø–ª–∞–Ω–∞",
        "favorites_updated": "–∏–∑–º–µ–Ω—ë–Ω —Å–ø–∏—Å–æ–∫ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ",
        "shopping_viewed": "–ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω —Å–ø–∏—Å–æ–∫ –ø–æ–∫—É–ø–æ–∫",
        "statistics_viewed": "–ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
        "reminder_scheduled": "—Å–æ–∑–¥–∞–Ω–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ",
        "reminder_sent": "–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ",
        "imported": "–∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã –±–ª—é–¥–∞",
    }
    lines = ["–ù–µ–¥–∞–≤–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è:"]
    for action in actions:
        description = mapping.get(action.get("action"), action.get("action"))
        timestamp = action.get("created_at", "")
        lines.append(f"‚Ä¢ {timestamp}: {description}")
    return "\n".join(lines)


def format_statistics(stats: Dict[str, Any], actions: Sequence[Dict[str, Any]]) -> str:
    lines = ["üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è"]
    lines.append(f"–í—Å–µ–≥–æ –±–ª—é–¥ –≤ –±–∞–∑–µ: {stats.get('total_dishes', 0)}")
    lines.append(f"–ò–∑–±—Ä–∞–Ω–Ω—ã—Ö –±–ª—é–¥: {stats.get('favorite_dishes', 0)}")
    if stats.get("top_categories"):
        top_categories = ", ".join(
            f"{row['category']} ({row['count']})" for row in stats["top_categories"]
        )
        lines.append("–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: " + top_categories)
    if stats.get("top_planned"):
        top_planned = ", ".join(
            f"{row['name']} ({row['count']})" for row in stats["top_planned"]
        )
        lines.append("–ß–∞—â–µ –≤—Å–µ–≥–æ –≤ –ø–ª–∞–Ω–µ: " + top_planned)
    if stats.get("activity"):
        lines.append(
            "–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å: "
            + ", ".join(f"{key} ‚Äî {value}" for key, value in stats["activity"].items())
        )
    recent = format_recent_actions(actions)
    if recent:
        lines.append("\n" + recent)
    return "\n".join(lines)


def scale_ingredients(
    ingredients: Sequence[Dict[str, Any]],
    base_servings: float,
    new_servings: float,
) -> List[Dict[str, Any]]:
    if base_servings <= 0:
        ratio = 1.0
    else:
        ratio = new_servings / base_servings
    scaled: List[Dict[str, Any]] = []
    for ingredient in ingredients:
        scaled_item = dict(ingredient)
        if ingredient.get("quantity") is not None:
            scaled_item["quantity"] = (ingredient["quantity"] or 0) * ratio
        for key in ("calories", "protein", "fat", "carbs"):
            if ingredient.get(key) is not None:
                scaled_item[key] = (ingredient[key] or 0) * ratio
        scaled.append(scaled_item)
    return scaled


def format_scaled_ingredients(dish: Dict[str, Any], new_servings: float) -> str:
    base_servings = float(dish.get("servings") or 1)
    scaled = scale_ingredients(dish.get("ingredients_list", []), base_servings, new_servings)
    macros = compute_macros(scaled)
    lines = [
        f"–ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ—Ü–µ–ø—Ç–∞ '{dish.get('name')}'",
        f"–ë–∞–∑–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ä—Ü–∏–π: {base_servings}",
        f"–ù—É–∂–Ω–æ –ø—Ä–∏–≥–æ—Ç–æ–≤–∏—Ç—å: {new_servings}",
        "\n–ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã:",
        format_ingredients_list(scaled),
    ]
    macros_line = format_macros(macros)
    if macros_line:
        lines.append(f"\n–ü–∏—â–µ–≤–∞—è —Ü–µ–Ω–Ω–æ—Å—Ç—å –¥–ª—è {new_servings} –ø–æ—Ä—Ü.: {macros_line}")
    return "\n".join(lines)


def format_shareable_recipe(dish: Dict[str, Any]) -> str:
    lines = [f"{dish.get('name', '–†–µ—Ü–µ–ø—Ç')}" ]
    ingredients = format_ingredients_list(dish.get("ingredients_list", []))
    if ingredients:
        lines.append("–ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã:\n" + ingredients)
    instructions = dish.get("instructions") or dish.get("recipe")
    if instructions:
        lines.append("\n–†–µ—Ü–µ–ø—Ç:\n" + instructions)
    return "\n".join(lines)


def format_search_results(results: Sequence[Dict[str, Any]]) -> str:
    if not results:
        return "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –±–ª—é–¥–∞ —Å —Ç–∞–∫–∏–º–∏ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–∞–º–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Ä–∞—Å—à–∏—Ä–∏—Ç—å —Å–ø–∏—Å–æ–∫." \
            "\n–°–Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤—å—Ç–µ –±–ª—é–¥–∞ —á–µ—Ä–µ–∑ '–î–æ–±–∞–≤–∏—Ç—å –±–ª—é–¥–æ'."
    lines = ["–ù–∞–π–¥–µ–Ω–Ω—ã–µ –±–ª—é–¥–∞:"]
    for entry in results[:10]:
        matched = ", ".join(entry.get("matched", []))
        missing = ", ".join(entry.get("missing", []))
        coverage = round(entry.get("coverage", 0) * 100)
        line = f"‚Ä¢ {entry.get('name')} ‚Äî —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π {coverage}%"
        if matched:
            line += f"\n  –ï—Å—Ç—å: {matched}"
        if missing:
            line += f"\n  –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç: {missing}"
        lines.append(line)
    return "\n".join(lines)


def calculate_date_range(days: int = 7) -> Tuple[str, str]:
    today = date.today()
    end = today + timedelta(days=days - 1)
    return today.isoformat(), end.isoformat()
